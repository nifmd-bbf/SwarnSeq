% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SwarnAdjLRT.R
\name{SwarnAdjLRT}
\alias{SwarnAdjLRT}
\title{Differential gene expression analysis for single-cell data}
\usage{
SwarnAdjLRT(
  CountData,
  norm.method = c("DEseq.norm", "TMM", "log1p"),
  group,
  CellCluster,
  CellAuxil = NULL,
  maxit = 100,
  eps = 1e-04,
  muoffset = NULL,
  phioffset = NULL,
  weights = NULL,
  method = "ML",
  p.value.adj.method = "BH",
  RNAspike.use = FALSE,
  spikes,
  spike.conc,
  CE.range = c(0.01, 0.5)
)
}
\arguments{
\item{CountData}{This is a gene-by-cell raw count matrix.}

\item{norm.method}{There are three distinct statistical normalization methods for scRNA-seq count data:DESeq2, a maximum likelihood approach described by Ye et al. (2027); TMM, a trimmed mean method introduced by Robinson et al. (2010), both designed to correct for library size and compositional biases; and a third method, which is the log1p standard normalization method for scRNA-seq data.}

\item{group}{This is a vector of factors with 2 levels that serves as a grouping variable that assigns each column (cell) of the count matrix to one of two predefined experimental conditions.}

\item{CellCluster}{This is a vector of factors with the optimal number of cluster levels, with each entry assigning a cell from the count matrix's columns to its computationally inferred cluster identity.}

\item{CellAuxil}{This is a vector of factors of cell-level metadata that provides additional information about each cell, such as its batch, donor, or quality control metrics, with each entry aligning to a column in the count matrix.}

\item{maxit}{This is the maximum number of iterations for the Expected-Maximization (EM) algorithm.}

\item{eps}{This is the convergence criteria for the Expected-Maximization (EM) algorithm.}

\item{muoffset}{This is the offset parameter for mean (mu), with a default value of NULL.}

\item{phioffset}{This is the offset parameter for the zero inflation (phi) parameter, with a default value of NULL.}

\item{weights}{This is the observation-wise weight for the cells, with a default value of NULL.}

\item{method}{A string that specifies the method for computing capture efficiencies. ("ML" or "")}

\item{p.value.adj.method}{A string that specifies the method for multiple hypothesis correction, which can be any of the following values: "holm," "hochberg," "hommel," "bonferroni," "BH," "BY," "fdr," or "none").}

\item{RNAspike.use}{This is a logical parameter. If this parameter is set to TRUE, then it requires you to provide spike counts (spike) and spike concentration (spike.conc) information.}

\item{spikes}{This is the observed count matrix for spike-in transcripts, where each row is a spike-in and each column is a cell. It's only required if you set RNAspike.use to TRUE.}

\item{spike.conc}{This is a vector of theoretical counts for each spike-in transcript in a single cell, and it's only required if you set RNAspike.use to TRUE.}

\item{CE.range}{This is a two-element vector that sets the lower and upper limits for the estimated range of capture efficiencies.}
}
\value{
This function analyzes single-cell RNA-sequencing adjusted normalized data to find differentially expressed genes and returns a list of the results.
}
\description{
This function performs differential gene expression (DEG) analysis on a single-cell RNA-sequencing (scRNA-seq) raw read counts matrix.
The input is a non-negative integer matrix, where rows correspond to genes and columns to individual cells.
The primary objective is to identify genes with statistically significant changes in expression levels between teo predefined groups of cells.
This analysis is a downstream step following the initial read mapping and gene counting, which generates the input matrix. By contrasting the expression profiles of the two groups, the function identifies biomarkers or genes that characterize the biological differences between them.
}
\examples{
# Do not run.
library(SwarnSeq)
# Load the test data.
data(TestData)
CountData <- as.matrix(TestData$CountData[1:100,1:50])
X <- cbind(CountData, TestData$CountData[1:100,300:349])
group <- c(rep(1,50), rep(2,50))
CellCluster <- c(rep(1,30), rep(2,20), rep(3, 10), rep(4, 15), rep(5, 25))
group <- as.factor(group)
clust <- as.factor(CellCluster)
# CellAuxil <- as.factor(c(rep("A",14), rep("B",26), rep("C", 40), rep("E", 20)))  # Optional
res <- SwarnSeq::SwarnAdjLRT(CountData=X,norm.method="DEseq.norm",group=group,CellCluster=clust)
}
